<!--
Sync Impact Report
==================
Version Change: N/A → 1.0.0
Change Type: Initial Constitution
Ratification Date: 2026-02-24

Added Principles:
- I. 程式碼品質 (Code Quality)
- II. 測試標準 (Testing Standards)
- III. 使用者體驗一致性 (User Experience Consistency)
- IV. 效能要求 (Performance Requirements)
- V. 文件與可觀測性 (Documentation & Observability)

Added Sections:
- 開發流程 (Development Workflow)
- 程式碼審查標準 (Code Review Standards)
- 治理 (Governance)

Template Updates:
✅ spec-template.md - Compatible with zh-TW requirements and UX consistency principles
✅ plan-template.md - Constitution Check section aligns with all 5 principles
✅ tasks-template.md - Task structure supports test-first approach and quality gates
⚠ Future: All generated specs, plans, tasks must be in zh-TW per constitution

Follow-up TODOs:
- None (all placeholders filled)
-->

# Pencil History 專案憲章

## 核心原則

### I. 程式碼品質

**強制性**：所有提交的程式碼必須符合以下標準

- 程式碼必須清晰、可讀且自我說明
- 遵循一致的命名規範：變數使用 camelCase、常數使用 UPPER_SNAKE_CASE、類別使用 PascalCase
- 函式和方法必須保持單一職責原則（Single Responsibility Principle）
- 避免過度工程化：只實作當前需求，不預先設計未來可能需要的功能
- 程式碼複雜度必須有充分理由：優先選擇簡單直接的解決方案
- 禁止提交含有明顯安全漏洞的程式碼（如 SQL 注入、XSS、命令注入等 OWASP Top 10 漏洞）
- 必須使用自動化 linting 工具（ESLint、Prettier 等）確保程式碼風格一致

**理由**：程式碼品質直接影響專案的可維護性、協作效率和長期發展。清晰的程式碼減少認知負擔，降低 bug 引入機率，並加速新成員上手。

### II. 測試標準

**強制性**：所有功能必須經過適當測試

- **測試優先原則**：在實作功能前，必須先撰寫失敗的測試
- 遵循 Red-Green-Refactor 循環：先寫測試（紅）→ 實作功能使測試通過（綠）→ 重構優化（保持綠燈）
- 必須包含的測試類型：
  - **契約測試（Contract Tests）**：驗證 API 介面和資料結構符合規範
  - **整合測試（Integration Tests）**：驗證多個元件協同運作
  - **單元測試（Unit Tests）**：僅在明確要求時撰寫
- 測試必須獨立且可重複執行：不依賴執行順序，不依賴外部狀態
- 測試必須清楚描述預期行為：使用 Given-When-Then 或 Arrange-Act-Assert 模式
- 所有邊界條件和錯誤情況必須有對應測試案例
- 測試覆蓋率目標：核心業務邏輯 ≥ 80%

**理由**：測試是品質保證的基礎，也是活文件。測試優先的方法迫使開發者思考需求和介面設計，減少返工。完善的測試套件讓重構和新功能開發更有信心。

### III. 使用者體驗一致性

**強制性**：所有使用者介面和互動必須保持一致

- 視覺一致性：
  - 使用統一的設計系統（顏色、字型、間距、圓角等）
  - 相同功能的元件必須使用相同的視覺樣式
  - 響應式設計必須在所有裝置上提供一致的體驗
- 互動一致性：
  - 相同操作必須產生相同結果（例如：刪除按鈕行為一致）
  - 鍵盤導航和無障礙功能必須在整個應用程式中可用
  - 錯誤訊息和成功提示使用統一的格式和位置
- 內容一致性：
  - 術語和文案保持一致（建立統一的詞彙表）
  - 多語系支援必須完整且準確（優先支援 zh-TW）
  - 所有規格文件和計畫文件必須使用繁體中文（zh-TW）撰寫
- 效能一致性：
  - 頁面載入時間應保持在可接受範圍內（見效能要求）
  - 動畫和過渡效果在各瀏覽器/裝置上應有相似的流暢度

**理由**：一致的使用者體驗降低學習成本，增強使用者信任感，減少支援成本。不一致的介面讓使用者困惑，影響產品專業形象。

### IV. 效能要求

**強制性**：所有功能必須符合效能基準

- **回應時間要求**：
  - API 端點 P95 延遲 < 200ms
  - 頁面首次內容渲染（FCP）< 1.5s
  - 頁面可互動時間（TTI）< 3.0s
  - 使用者操作回饋延遲 < 100ms
- **資源使用限制**：
  - 前端 JavaScript bundle 大小 < 500KB（gzipped）
  - 單頁記憶體佔用 < 100MB
  - 後端服務記憶體佔用 < 512MB（待確認）
- **可擴展性**：
  - 系統必須能處理至少 1,000 並發使用者
  - 資料庫查詢必須使用索引，複雜查詢需經過 EXPLAIN 分析
  - 靜態資源必須使用 CDN 和瀏覽器快取
- **效能監控**：
  - 所有關鍵路徑必須有效能追蹤
  - 建立效能基準測試並在 CI/CD 中執行
  - 效能退化必須在部署前被偵測並修正

**例外處理**：若無法達成效能要求，必須在實作計畫中明確說明原因和替代方案。

**理由**：效能直接影響使用者體驗和滿意度。緩慢的應用程式導致使用者流失和負面評價。明確的效能要求確保團隊優先考慮效能優化。

### V. 文件與可觀測性

**強制性**：系統必須易於理解和除錯

- **文件要求**：
  - 每個功能必須有對應的規格文件（spec.md）和實作計畫（plan.md）
  - 所有規格和計畫文件必須使用繁體中文（zh-TW）撰寫
  - API 端點必須有完整的契約文件（contracts/）
  - 快速入門指南（quickstart.md）必須保持更新且可驗證
  - 複雜的業務邏輯必須有內聯註解說明「為什麼」而非「做什麼」
- **日誌要求**：
  - 所有關鍵操作必須記錄結構化日誌（JSON 格式）
  - 日誌必須包含：時間戳、嚴重性級別、操作 ID、使用者 ID（若適用）、錯誤堆疊
  - 錯誤日誌必須包含足夠的上下文資訊以重現問題
- **可觀測性**：
  - 所有外部依賴（資料庫、API）呼叫必須有追蹤和計時
  - 關鍵業務指標必須可量測和監控
  - 系統必須提供健康檢查端點
- **除錯性**：
  - 錯誤訊息必須清楚描述問題和建議的解決步驟
  - 開發環境必須支援詳細的除錯資訊
  - 生產環境必須記錄足夠資訊以事後分析問題

**理由**：良好的文件和可觀測性大幅降低維護成本和故障排除時間。清晰的日誌和追蹤能快速定位問題，減少系統停機時間。

## 開發流程

### 功能開發流程

1. **規格階段**：使用 `/speckit.specify` 建立功能規格（spec.md，zh-TW）
   - 必須定義使用者故事和驗收標準
   - 必須列出功能需求（Functional Requirements）
   - 必須定義成功標準（Success Criteria）

2. **計畫階段**：使用 `/speckit.plan` 建立實作計畫（plan.md，zh-TW）
   - 必須通過憲章檢查（Constitution Check）
   - 必須定義技術上下文和專案結構
   - 複雜度必須有充分理由

3. **任務階段**：使用 `/speckit.tasks` 產生任務清單（tasks.md）
   - 任務必須依使用者故事分組
   - 測試任務必須在實作任務之前
   - 必須標註任務相依性和可平行執行的任務

4. **實作階段**：使用 `/speckit.implement` 執行實作
   - 遵循測試優先原則：先寫測試 → 測試失敗 → 實作功能 → 測試通過
   - 頻繁提交：完成邏輯性工作單元即提交
   - 每個使用者故事完成後必須獨立驗證

5. **審查階段**：提交 Pull Request
   - 必須通過所有自動化測試
   - 必須通過程式碼審查（見下節）
   - 必須符合所有核心原則

### 分支策略

- **主分支（main）**：永遠保持可部署狀態
- **功能分支**：格式為 `###-feature-name`，從 main 分支建立
- **提交訊息**：使用語義化提交訊息（Conventional Commits）
  - 格式：`<type>(<scope>): <description>`
  - 類型：feat, fix, docs, style, refactor, test, chore
  - 範例：`feat(auth): 新增使用者登入功能`

### 緊急修復流程

- 嚴重 bug 可跳過完整規格階段，但必須：
  - 建立簡化規格說明問題和修復方案
  - 撰寫回歸測試確保問題不再發生
  - 事後補充完整文件

## 程式碼審查標準

### 審查檢查清單

所有 Pull Request 必須通過以下檢查：

- [ ] **憲章合規性**：程式碼符合所有核心原則
- [ ] **測試覆蓋**：包含必要的契約測試和整合測試，測試優先原則已遵循
- [ ] **程式碼品質**：清晰可讀，無不必要的複雜度，通過 linting
- [ ] **效能影響**：無明顯效能退化，關鍵路徑已優化
- [ ] **UX 一致性**：介面和互動符合設計系統和一致性原則
- [ ] **安全性**：無明顯安全漏洞，敏感資料妥善處理
- [ ] **文件更新**：相關文件已更新（API 文件、quickstart.md 等）
- [ ] **可觀測性**：適當的日誌和錯誤處理
- [ ] **向後相容性**：破壞性變更必須有遷移計畫和版本號更新

### 審查者責任

- 審查者必須實際運行程式碼並驗證功能
- 審查者必須檢查測試是否真正覆蓋需求
- 審查者有權要求補充測試或重構
- 審查者必須在 24 小時內回應審查請求（工作日）

### 自動化檢查

以下檢查必須自動化並在 CI/CD 中執行：

- Linting 和格式化檢查
- 單元測試、整合測試、契約測試
- 效能基準測試
- 安全漏洞掃描
- 程式碼覆蓋率報告

## 治理

### 憲章地位

- 本憲章為專案最高指導文件，所有開發實踐必須遵循本憲章
- 當其他文件或實踐與本憲章衝突時，以本憲章為準
- 所有 Pull Request 和程式碼審查必須驗證憲章合規性

### 修訂程序

憲章修訂必須經過以下流程：

1. **提案階段**：提交憲章修訂提案，說明修訂原因和影響範圍
2. **討論階段**：團隊討論提案，評估影響和可行性（至少 3 個工作日）
3. **投票階段**：需獲得團隊多數成員同意（> 50%）
4. **遷移計畫**：若修訂影響現有程式碼，必須制定遷移計畫
5. **更新階段**：更新憲章並同步更新所有相依模板和文件
6. **公告階段**：向全體成員公告修訂內容和生效日期

### 版本管理

- 使用語義化版本號：MAJOR.MINOR.PATCH
  - **MAJOR**：向後不相容的治理或原則移除/重新定義
  - **MINOR**：新增原則/章節或大幅擴展指導內容
  - **PATCH**：釐清、措辭、錯字修正、非語義性改善
- 每次修訂必須更新版本號和最後修訂日期
- 重大修訂（MAJOR）必須在 `LAST_AMENDED_DATE` 記錄

### 合規性審查

- 每季進行一次憲章合規性審查
- 審查範圍：最近提交的程式碼、文件、測試覆蓋率、效能指標
- 審查結果必須記錄並公告，不合規項目必須制定改善計畫
- 持續違反憲章的程式碼必須重構或移除

### 例外處理

- 若遇特殊情況無法遵循憲章某項原則，必須：
  1. 在實作計畫（plan.md）的「複雜度追蹤」表格中記錄違規項目
  2. 說明為何需要此例外以及為何更簡單的替代方案不可行
  3. 取得至少兩位資深開發者的審查同意
  4. 在程式碼中加註解說明此例外的理由和預期移除時間

### 運行時指導

- 開發過程中的實時指導遵循本憲章原則
- Speckit 命令（`/speckit.*`）產生的所有文件必須符合本憲章要求
- 團隊成員在不確定時應查閱本憲章，而非自行決定

---

**版本**：1.0.0 | **批准日期**：2026-02-24 | **最後修訂**：2026-02-24
